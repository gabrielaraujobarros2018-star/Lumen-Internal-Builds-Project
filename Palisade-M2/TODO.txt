==================
PalisadeOS M2 TODO
==================

Complete this TODO Within 1 month before PalisadeOS M2 releases.

[Wifi Connection] (Done!)
- Compile files under /wf_con

[Palikey] (Done!)
- Implement Palikey
- Polish Palikey for PalisadeOS
- Better emoji support

[Boot path validation] (Done!)
- Verify cold boot paths: UEFI → kernel and Android bootloader → kernel
- Add early boot log buffer (pre-filesystem)
- Expose /proc/bootinfo (bootloader, mode, device class)

[init Sequencing] (Done!)
- Deterministic init order file (/palisade/init.seq)
- Fail-safe init stage with timeout and fallback shell
- Init service dependency resolution (minimal DAG)

[Memory Management] (Done!)
- Early memory map dump (usable/reserved/IO)
- Page allocator stats endpoint
- Memory pressure notification hook

[Scheduler Foundations] (Done!)
- Basic priority classes (foreground, background, system)
- Idle thread specialization (mobile vs desktop)
- Cooperative + preemptive hybrid flag

[Debug Facilities] (Done!)
- Unified logging daemon
- Log levels with runtime toggling
- Ring buffer logs for early boot

[Inspection Tools] (Done!)
- /sys/palisade/ inspection tree
- Live system state viewer app
- Build fingerprint exposure

[Web] (Done!)
- Create a WebView
- Implement content filters

[Packaging]
- PPAK System Utility (Palisade Packaging App Kit)
- .papp File Extension

[GIFs]
- Implement gif support
- Make some GIFs for PalisadeOS
- Integration of GIFs into Palikey

[Apps]
- AI Assistant app for PalisadeOS (Assists in System management)
- Make the other apps

[Device management and HALs]
- Tighten device support (Expand/create Drivers, Add more HALs, Add more USB/HDMI Support)
- Device Settings

[Code]
- Expand some files without Recompiling anything
- Create files in some empty folders without Recompiling anything

[GC]
- Implement Java garbage collection

[Power Management]
- CPU governor stub (performance / balanced / powersave)
- Screen state power hooks
- Battery status HAL abstraction

[Thermal]
- Thermal zone reader abstraction
- Throttle notification channel to userland
Emergency thermal shutdown path

[Threads]
- Add threads
- Add thread management
- Add thread handling

[TTS]
- Add Text-to-speech System
- Add Talkback
- Add voice tutorials

[Tutorials]
- Create a /ttrals folder inside /palisade/os and add Tutorial files for Home screen, setup wizard, Lock screen, Login GUI, and TTS without touching existing folders

[.cfg Config parsing]
- Ignore empty lines
- Ignore lines starting with # or ; (recommended, even if unused initially)
- Trim leading/trailing whitespace around keys and values
- First = splits the line (everything after belongs to the value)
- Keys must be ASCII [A-Za-z0-9_.-]
- Values are raw strings (no escaping)

[.json Config parsing]
- Root MUST be a single JSON object ({}), never an array
- Keys MUST be strings using [A-Za-z0-9_.-] only
- Values allowed: string, number, boolean, or null
- No nested objects beyond one level (flat or shallow JSON)
- Arrays are forbidden
- Duplicate keys are forbidden
- Key order is not significant
- UTF-8 only, no BOM
- Trailing commas are forbidden
- Comments are forbidden
- Configuration files MUST end with .json

[Settings Activity config]
- Must contain the Settings App's Menus and options like in android
- Should parse and display the menus & options in the Settings app
- New dependency: "StAct"

[Filesystem Layer]
- Mount profiles (mobile, desktop, recovery)
- Read-only root with writable overlays (optional)
- Filesystem capability probing

[Integrity]
- Optional checksum verification for system files
- Boot-time filesystem sanity scan

[Networking Core]
- Unified network state daemon
- Network capability flags (metered, unmetered, local-only)
- IP stack status exposure to apps

[USB Networking]
- RNDIS / CDC-ECM groundwork
- Tethering stub (even if unused initially)

[App Lifecycle]
- App state model (created, paused, background, killed)
- Low-memory app eviction policy
- App privilege tiers (system, trusted, user)

[AI Assistant Hardening]
- Command permission gating
- Dry-run mode for system actions
Action audit log

[Display Abstraction]
- Multiple display handling (internal + HDMI)
- DPI / scale factor negotiation
- Orientation sensor hook

[Input]
- Unified input layer (touch, mouse, keyboard)
- Hardware key mapping table
- Accessibility input interception hooks

[Audio Core]
- Unified audio routing (speaker, headset, HDMI)
- Volume domains (media, system, call)
- Audio focus arbitration

[Media Framework]
- Basic codec probing
- Media capability reporting to apps

[Recovery Mode]
- Minimal recovery UI
- System repair hooks
- Factory reset with confirmation safeguards

[Update Readiness]
- Atomic update preparation hooks
- Rollback metadata format
- Update compatibility checker

[Debug Facilities]
- Unified logging daemon
- Log levels with runtime toggling
- Ring buffer logs for early boot

[Inspection Tools]
- /sys/palisade/ inspection tree
- Live system state viewer app
- Build fingerprint exposure

[Permission Model]
- Minimal permission manifest format
- Runtime permission checks
- System-only APIs enforcement

[Crash Handling]
- Kernel panic capture
- Userland crash dump format
- Safe-mode boot trigger after repeated failures

[Accessibility Framework]
- Accessibility service API
- Focus traversal rules
- High-contrast and large-text flags

[Config Validation]
- Strict schema validation for .cfg and .json
- Human-readable parse error reporting
- Config hot-reload for selected subsystems

[Dynamic Config Injection]
- Device-specific override directory
- Boot-time config layering

[Missing]
- Design and implement a real audio pipeline
  - Kernel-level audio driver with interrupt-driven buffering
  - Shared memory or ring-buffer mechanism for audio streams
  - Audio service responsible for mixing, routing, and focus
  - Clear separation between policy (framework) and mechanism (kernel)

- Implement persistent core services
  - Service supervisor in init
  - Explicit service lifecycle states (starting, ready, crashed, restarting)
  - Restart and dependency ordering policies
  - IPC-based service discovery (no direct kernel access from GUI)

- Establish deterministic input routing
  - Single input dispatcher service
  - Timestamped input events
  - Explicit focus and window ownership model
  - Prohibit direct device reads by GUI components

- Define and freeze the initial public API surface
  - Process and application lifecycle APIs
  - Audio control APIs (volume, focus, mute)
  - Display and window management APIs
  - Input and event APIs
  - Versioned and documented ABI boundaries

- Implement volume control end-to-end
  - Hardware volume control via audio driver
  - Audio service mediation
  - Framework-level API
  - GUI volume slider wired strictly through the stack

- Implement wallpaper management
  - Compositor support for background layers
  - Wallpaper service responsible for storage and state
  - Framework API for wallpaper changes
  - GUI control that invokes the service only

- Enforce strict GUI-to-service contracts
  - No GUI element without a backing service
  - GUI startup blocked until required services signal readiness
  - Hard failure on missing or unready services

- Formalize boot and startup ordering
  - Kernel boot → init → core services → readiness signals → GUI
  - Explicit dependency graph
  - No implicit timing assumptions

- Audit and remove any stubbed or placeholder functionality
  - Eliminate fake paths, mocks, or direct kernel calls from GUI
  - Ensure all exposed features survive a kernel-to-GUI audit

# M2 Code TODO

Let's set a rule: i'm allowed to do this TODO when i learn Begginner and Intermediary C/C++!

[Rewrites]
- Rewrite Memory Management code
- Rewrite Architecture code
- Rewrite init Code
- Rewrite xcall Code
- Rewrite UEFI/BIOS Code
- Rewrite bootguard Code
- Rewrite HW code
- Rewrite GUI Code
- Rewrite Framework code

[Expansions]
- Expand Bootloader code
- Expand Kernel code
- Expand Ramdisk code
- Expand userland code

[Delete]
- Delete old empty folders

[Modify]
- Boot contract
- All Makefiles
